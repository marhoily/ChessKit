<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# var args = new[]
{
    new Arg
    {
        Color = "White",
		Tests = new []
		{
		    new Tst
		    {
		        Name = "White pawn moves from e2 to e3 and e4 only",
		        Set = "E2:P",
				From = "E2",
				Legal = "E3, E4" 
		    }, 
		    new Tst
		    {
		        Name = "White pawn doesn't move from e2 if blocked on e3",
		        Set = "E2:P, E3:P",
				From = "E2",
				Legal = "" 
		    }, 
			new Tst
		    {
		        Name = "White pawn only moves from e2 to e3 if blocked on e4",
		        Set = "E2:P, E4:P",
				From = "E2",
				Legal = "E3" 
		    }, 
		    new Tst
		    {
		        Name = "White pawn only moves from e3 to e4",
		        Set = "E3:P",
				From = "E3",
				Legal = "E4" 
		    }, 
			new Tst
		    {
		        Name = "White pawn takes from e3 to d4 and f4",
		        Set = "E3:P, D4:p, F4:p",
				From = "E3",
				Legal = "E4, D4, F4" 
		    }, 
		}
    }
}; #>
using System;
using FluentAssertions;
using NUnit.Framework;

namespace ChessKit.ChessLogic.UnitTests
{
	partial class Bitboard
	{
<#
    foreach (var o in args)
	{
#>
		private bool IsLegal<#=o.Color#>PawnMove(ulong fromBit, ulong toBit)
		{
			var pushOnce = NortOne(fromBit);
			if (this[pushOnce] != BitType.Empty) return false;
			if (pushOnce == toBit) return true;
			if ((fromBit & Row2) == 0) return false;
			var pushTwice = NortOne(pushOnce);
			if (this[pushTwice] != BitType.Empty) return false;
			return pushTwice == toBit;
		}
<#
	}
#>		
 
	}
    [TestFixture]
    public class BitboardTest_PawnMoves
    {
        private Bitboard _bitboard;

        [SetUp]
        public void Initialize()
        {
            _bitboard = new Bitboard();
        }
<#
    foreach (var o in args)
	{
#>
<#
    foreach (var t in o.Tests)
	{
#>
        [Test]
        [TestCase(TestName="<#=t.Name#>")]
        public void IsLegalMove_For_<#=o.Color#>_Pawn_From_<#=t.From#>_To_Every_Other_Cell_Then_<#=string.Join("_",t.Expected)#>_Should_Return_False()
        {
<#
    foreach (var placement in t.Position)
	{
#>
            _bitboard[Bitboard.<#=placement.Coordinate#>] = <#=placement.Piece#>;
<#
	}
#>	
            _bitboard.AssertLegalMoves(<#=string.Join(", ",new[]{t.From}.Concat(t.Expected).Select(cell => "Bitboard."+cell))#>);
        }

<#
	}
#>	
<#
	}
#>		
    }
}
<#+

    class Placement
    {
        public string Coordinate { get; set; }
        public string Piece { get; set; }

        private static readonly Dictionary<string, string>
            Types = new Dictionary<string, string>
            {
				{"P", "BitType.WhitePawn"},
				{"p", "BitType.BlackPawn"},
            };
        public Placement(string coordinate, string piece)
        {
            Coordinate = coordinate.Trim();
            Piece = Types[piece.Trim()];
        }
    }
    class Tst
    {
        public IEnumerable<Placement> Position
        {
            get { return Set.Split(',').Select(x => new Placement(x.Split(':')[0], x.Split(':')[1])); }
        }
        public IEnumerable<string> Expected
        {
            get { return Legal.Split(new[]{','}, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()); }
        }
        public string Set { get; set; }
        public string From { get; set; }
        public string Legal { get; set; }
        public string Name { get; set; }
    }
	class Arg
	{
		public string Color { get; set; }
		public Tst[] Tests { get; set; }
	}
#>
