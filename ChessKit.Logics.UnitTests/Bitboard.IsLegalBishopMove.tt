<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="IsLegalMove.cs.ttinclude"#>
<# 
var args = new[]
{
    new Arg
    {
        Color = "White",
		Tests = new []
		{
		    new Tst
		    {
		        Name = "Validate white bishop moves from E4 on the empty board",
		        Set = "E4:B",
				From = "E4",
				Legal = "B1, C2, D3, F5, G6, H7, A8, B7, C6, D5, F3, G2, H1" 
		    }, 
		    new Tst
		    {
		        Name = "Validate white bishop moves from E4 on with obstacles",
		        Set = "E4:B, C2:B, H7:B, D5:b, H1:b",
				From = "E4",
				Legal = "D3, F5, G6, D5, F3, G2, H1" 
		    }, 
		}
    }
};
#>
using System;
using FluentAssertions;
using NUnit.Framework;

namespace ChessKit.ChessLogic.UnitTests
{
	partial class Bitboard
	{
<#
    foreach (var o in args)
	{
#>
		private bool IsLegal<#=o.Color#>BishopMove(int fromSquare, int toSquare)
		{
            // Get mask for the (from, to) reactangle 
		    var index = fromSquare*64 + toSquare; 
		    var boundaries = RectangularMasks[index]; 
			if (boundaries == 0) return false;
            // Get bishop attack pattern for the square
            var attackPattern = BishopAttackMasks[fromSquare];
            // Get attack ray that connects fromSquare and toSquare
            var attackRay = boundaries & attackPattern;
            if (attackRay == 0) return false;
            // The attack ray should not intercect 
            // with any pieces of the same color
            if ((~_occupance<#=o.Color#> & attackRay) != attackRay) return false;
            // The attack ray may only intercect piece of the opposite 
            // color in exactly one square: the toSquare
            var hitTargets = _occupance<#=o.OppositeColor#> & attackRay; 
		    var toBit = (1ul << toSquare); 
		    return (hitTargets | toBit) == toBit; 
		}
<#
	}
#>		
 
	}
    [TestFixture]
    public class BitboardTest_BishopMoves
    {
        private Bitboard _bitboard;

        [SetUp]
        public void Initialize()
        {
            _bitboard = new Bitboard();
        }
<#
    foreach (var o in args)
	{
#>
<#
    foreach (var t in o.Tests)
	{
#>
        [Test]
        [TestCase(TestName="<#=t.Name#>")]
        public void IsLegalMove_For_<#=o.Color#>_Bishop_From_<#=t.From#>_To_Every_Other_Cell_Then_<#=string.Join("_",t.Expected)#>_Should_Return_False()
        {
<#
    foreach (var placement in t.Position)
	{
#>
            _bitboard[Bitboard.<#=placement.Coordinate#>] = <#=placement.Piece#>;
<#
	}
#>	
            _bitboard.AssertLegalMoves(<#=string.Join(", ",new[]{t.From}.Concat(t.Expected).Select(cell => "Square."+cell))#>);
        }

<#
	}
#>	
<#
	}
#>		
    }
}
