<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="$(ProjectDir)bin\Debug\ChessKit.ChessLogic.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="ChessKit.ChessLogic.Primitives" #>
<#@ import namespace="ChessKit.ChessLogic.Internals" #>
using System.Collections.Generic;
using ChessKit.ChessLogic.Primitives;
using static ChessKit.ChessLogic.Primitives.MoveAnnotations;
using static ChessKit.ChessLogic.Scanning;

namespace ChessKit.ChessLogic
{
    partial class Board
    {
        private void GenerateMoves(Piece piece, int fromSquare,
             int? enPassantFile, Castlings castlingAvailability, List<Move> collector)
        {
            switch (piece)
            {
<#
    foreach (var p in MetaPiece.All) 
    {
#>
                #region ' <#=p.Color#> <#=p.PieceType#> '
                case Piece.<#=p.Color#><#=p.PieceType#>:
<#
        if (p.MoveDirections.Any(dir => dir.Count > 1))
        {
            foreach (var dir in p.MoveDirections)
            {
                var delta = dir.DeltaY * 16 + dir.DeltaX;
#>
                    for (var to = fromSquare + <#=delta#>; (to & 0x88) == 0; to += <#=delta#>)
                    {
                        var toPiece = _cells[to];
                        if (toPiece == 0)
                        {
                            _cells[fromSquare] = (byte)Piece.EmptyCell;
                            _cells[to] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                            if (!IsAttackedBy<#=p.Color.Invert()#>(_cells, _<#=p.Color.ToString().ToLower()#>KingPosition))
                                collector.Add(new Move(fromSquare, to, <#=p.PieceType#>));
                            _cells[fromSquare] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                            _cells[to] = toPiece;
                        }
                        else if ((Color)(toPiece & (byte)Color.Black) != Color.<#=p.Color#>)
                        {
                            _cells[fromSquare] = (byte)Piece.EmptyCell;
                            _cells[to] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                            if (!IsAttackedBy<#=p.Color.Invert()#>(_cells, _<#=p.Color.ToString().ToLower()#>KingPosition))
                                collector.Add(new Move(fromSquare, to, <#=p.PieceType#> | Capture));
                            _cells[fromSquare] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                            _cells[to] = toPiece;
                            break;
                        }
                        else break;
                    }
<#
            }
        }
        else if (p.PieceType == PieceType.Pawn)
        {
#>
                    Generate<#=p.Color#>PawnMoves(fromSquare, enPassantFile, collector);
<#
        }
        else // Non-slider move
        {
            foreach (var dir in p.MoveDirections.Where(m => !m.IsSpecial))
            {
                var delta = dir.DeltaY * 16 + dir.DeltaX;
#>
                    {
                        var to = fromSquare + <#=delta#>;
                        if ((to & 0x88) == 0)
                        {
                            var toPiece = _cells[to];
                            if (toPiece == 0)
                            {
                                _cells[fromSquare] = (byte)Piece.EmptyCell;
<#
                                if (p.PieceType != PieceType.King)
                                {
#>
                                _cells[to] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                                if (!IsAttackedBy<#=p.Color.Invert()#>(_cells, _<#=p.Color.ToString().ToLower()#>KingPosition))
<#
                                }
                                else
                                {
#>
                                if (!IsAttackedBy<#=p.Color.Invert()#>(_cells, to))
<#
                                }
#>
                                    collector.Add(new Move(fromSquare, to, <#=p.PieceType#>));
<#
                                if (p.PieceType != PieceType.King)
                                {
#>
                                _cells[to] = toPiece;
<#
                                }
#>
                                _cells[fromSquare] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                            }
                            else if ((Color)(toPiece & (byte)Color.Black) != Color.<#=p.Color#>)
                            {
                                _cells[fromSquare] = (byte)Piece.EmptyCell;
<#
                                if (p.PieceType != PieceType.King)
                                {
#>
                                _cells[to] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                                if (!IsAttackedBy<#=p.Color.Invert()#>(_cells, _<#=p.Color.ToString().ToLower()#>KingPosition))
<#
                                }
                                else
                                {
#>
                                if (!IsAttackedBy<#=p.Color.Invert()#>(_cells, to))
<#
                                }
#>
                                    collector.Add(new Move(fromSquare, to, <#=p.PieceType#> | Capture));
<#
                                if (p.PieceType != PieceType.King)
                                {
#>
                                _cells[to] = toPiece;
<#
                                }
#>
                                _cells[fromSquare] = (byte)Piece.<#=p.Color#><#=p.PieceType#>;
                            }
                        }
                    }
<#
                }
            }
            if (p.PieceType == PieceType.King)
            {
#>
                    Generate<#=p.Color#>CastlingMoves(fromSquare, castlingAvailability, collector);
<#
            }
#>
                    break;
                #endregion

<#                 
        }
#>
            }
        }
    }
}